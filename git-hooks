#!/usr/bin/env bash
invocation="${_:-}"
set -eu -o pipefail

# Borrowed from https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
unset CDPATH
bash_source="${BASH_SOURCE[0]}"
while [[ -h "$bash_source" ]]; do
    bash_source_dir="$(cd -P "$(dirname "$bash_source")" >/dev/null && pwd)"
    bash_source="$(readlink "$bash_source")"
    [[ "$bash_source" != /* ]] && bash_source="${bash_source_dir}/${bash_source}"
done
bash_source_dir="$(cd -P "$(dirname "$bash_source")" >/dev/null && pwd)"
bash_source="${bash_source_dir}/${bash_source##*/}"

# shellcheck disable=1090
. "${bash_source_dir}/included/lib/colors.sh" "${bash_source_dir}/included/lib"

color="$(git config --bool git-hooks.color)" || color=true
if "$color" &>/dev/null; then
    c_action="${c_action:-${cyan}}"
    c_value="${c_value:-${yellow}}"
    c_error="${c_error:-${red}}"
    c_warning="${c_warning:-${b_red}}"
    c_missing="${c_missing:-${b_black}}"
else
    c_action=""
    c_value=""
    c_error=""
    c_warning=""
    c_missing=""
    c_reset=""
fi

# Hard-coded here for speed, but might get out of sync with actual supported
# hooks if git gets new hooks in future versions. See check-support for details.
git_hook_names=(
    applypatch-msg
    commit-msg
    fsmonitor-watchman
    post-applypatch
    post-checkout
    post-commit
    post-merge
    post-receive
    post-rewrite
    post-update
    pre-applypatch
    pre-auto-gc
    pre-commit
    pre-push
    pre-rebase
    pre-receive
    prepare-commit-msg
    push-to-checkout
    sendemail-validate
    update
)



function git_hooks__ensure_modern_bash {
    # Ensure that the user has a modern version (>= 4.*) of the bash shell (silly mac users)
    case "${BASH_VERSION}" in
        4.*) ;;
        *)  printf >&2 "${c_error}%s${c_reset}\\n" "Upgrade your bash to version 4.*"
            exit 1
            ;;
    esac
}


function git_hooks__ensure_gnu_getopt {
    # We depend on GNU getopt for option parsing, but we don't expect
    # OSX users to install it over their built-in getopt command.
    set +e
    getopt -T &>/dev/null
    if [[ $? -eq 4 ]]; then
        getopt=getopt
    elif brew --prefix gnu-getopt &>/dev/null; then
        getopt=$(brew --prefix gnu-getopt)/bin/getopt
    elif command -v port &>/dev/null; then
        getopt=/opt/local/bin/getopt
    else
        printf >&2 "${c_error}%s${c_reset}\\n" "Install GNU getopt (see README)"
        exit 1
    fi

    # Final check because 'brew --prefix' can return a path that points to nothing.
    if ! command -v $getopt &>/dev/null; then
        printf >&2 "${c_error}%s${c_reset}\\n" "Could not find GNU getopt"
        exit 1
    fi
    set -e
}

function git_hooks__ensure_collection {
    local collections_path="${githooks_dir}/.collections"
    local c_name="$1"

    [[ -d "${collections_path}/${c_name}" ]]
    (pushd "${collections_path}/${c_name}" &>/dev/null; git rev-parse --is-inside-work-tree &>/dev/null)
}

# Utility functions for README.md
function md {
    if $USE_MARKDOWN; then
        echo -n "$@"
    fi
}

function md_omit {
    if ! $USE_MARKDOWN; then
        echo -n "$@"
    fi
}

function md_inline_quotes {
    if $USE_MARKDOWN; then
        echo -n "\`$*\`"
    else
        echo -n "'$*'"
    fi
}

function md_inline_monospace {
    if $USE_MARKDOWN; then
        echo -n "\`$*\`"
    else
        echo "$@"
    fi
}

function md_block_monospace {
    if $USE_MARKDOWN; then
        echo -e "\`\`\`\\n$*\\n\`\`\`"
    else
        echo "$@"
    fi
}

function md_no_indent_or_hash {
    if $USE_MARKDOWN; then
        sed 's/^[ \t]*[#]*[ \t]*//' <<< "$@"
    else
        echo "$@"
    fi
}


# HELP
#############################################
read -r -d '' GITHOOKS_HELP <<'HELP' ||:
$(md '# git-hooks')
$(md_omit "git-hooks - ")A tool for managing and invoking custom git hook scripts.

$(md '##') Description:
$(md_no_indent_or_hash "
    git-hooks is a tool to facilitate git hook management, specifically being
    able to store your hooks under source control within the repository itself
    and simply reference them from a multiplexer hook installed in the
    $(md_inline_monospace .git/hooks) directory.

    The expected usage is to write an arbitrary number of individual hook
    scripts associated with a single standard git hook and store them in the
    $(md_inline_monospace '.githooks') directory. When git invokes the multiplexer script in $(md_inline_monospace .git/hooks),
    it will call your custom scripts sequentially, or in parallel if you
    configure it to do so.

    This way you can break your monolithic hooks into individual files, giving
    you greater flexibility regarding which pieces to run and when.
")

$(md '##') Installation:

$(md '#### ')$(md_no_indent_or_hash "    # Install GNU getopt (if not already present for your platform).")
$(md_block_monospace '
    getopt -T
    if [[ $? -ne 4 ]]; then
        brew install gnu-getopt
        # -- or --
        sudo port install getopt
    fi
')

$(md '#### ')$(md_no_indent_or_hash "    # Install $(md_inline_quotes 'git hooks')")
$(md_no_indent_or_hash "
    # This will symlink $(md_inline_monospace git-hooks) to $(md_inline_monospace /usr/local/bin).
    # This allows $(md_inline_monospace git) to treat it as a first-class command. In other words, you can invoke its behavior
    # via $(md_inline_monospace git hooks ...).
")
$(md_block_monospace '    path/to/git-hooks/git-hooks install-command')

$(md '#### ')$(md_no_indent_or_hash "    # Install the multiplexers into a repository")
$(md_block_monospace '
    cd <to your repo>
    git hooks install
')

$(md '#### ')$(md_no_indent_or_hash "    # Configure git to automatically install the multiplexers for all new repos (cloned or init'ed)")
$(md_no_indent_or_hash "
    # This will make it so that you never have to run $(md_inline_quotes 'git hooks install') again for this machine.
    # This is useful when your repositories already have a $(md_inline_monospace '.githooks') directory with hook
    # scripts in it or if you plan to make regular use of the $(md_inline_quotes 'git hooks') functionality in other
    # or future repositonies.
")
$(md_block_monospace '
    git hooks install-template
')

$(md '##') Usage:
        git hooks  # equivalent to list
    or: git hooks $(git_hooks__extract_desc list)
    or: git hooks $(git_hooks__extract_desc enable)
    or: git hooks $(git_hooks__extract_desc disable)
    or: git hooks $(git_hooks__extract_desc run)
    or: git hooks $(git_hooks__extract_desc install)
    or: git hooks $(git_hooks__extract_desc uninstall)
    or: git hooks $(git_hooks__extract_desc install-command)
    or: git hooks $(git_hooks__extract_desc uninstall-command)
    or: git hooks $(git_hooks__extract_desc install-template)
    or: git hooks $(git_hooks__extract_desc uninstall-template)
    or: git hooks $(git_hooks__extract_desc add-collection)
    or: git hooks $(git_hooks__extract_desc include)
    or: git hooks $(git_hooks__extract_desc check-support)
    or: git hooks $(git_hooks__extract_desc parallel)
    or: git hooks $(git_hooks__extract_desc show-input)
    or: git hooks $(git_hooks__extract_desc config)
    or: git hooks $(git_hooks__extract_desc help)

$(md '##') Common Arguments:
    <path>...
        The command accepts a list of path strings.

    <git hook>...
        The command accepts a list of git hook names. These names should only
        include the names of the standard git hooks:

$(echo ${git_hook_names[@]} | xargs -L1 -n1 | sed 's/^/            /g')

    <custom script name>...
        The command accepts a list of hook script names. These names must
        indicate scripts in the repo's .githooks directory. Standard git hook
        names are not considered valid items in this list.

$(md '##') Files:
    .githooks/
        This is where git-hooks will look for default hook scripts. Place your
        hook scripts in here rather than .git/hooks. Your hook scripts should
        be executable and follow the naming convention:

            <standard git hook name>-<custom suffix>[.<file extension>]

        They will be executed in alphabetical order, so if you wish to control
        the order of execution, take that into account when naming the files.

        Examples: .githooks/pre-commit-00-style.sh
                  .githooks/pre-commit-01-unittest.py

    .git/config
        git-hooks config settings will be stored in your repository's config
        file. In the case of a bare repository, the config file is located at
        ./config.

    ~/.gitconfig
        Some configs, such as unicode output and color output support will be stored here.
        Additionally, the periodic update check information is stored here.

    ~/.gittemplate/hooks
    ~/.gittemplate/info/exclude
        These files will be updated if you choose to install the hooks into your
        repository template by running 'git hooks install-template'.

$(md '##') Configuration:
    Set these git config values (recommended that you use --global) to modify git-hooks behavior.

    git-hooks.unicode [default=true]
        Use unicode glyphs in certain operations' output (eg. git-hooks list)
        If false, standard ascii characters will be used instead

    git-hooks.color [default=true]
        Use colorized output.

    git-hooks.last-check
        Internal use only.
        Records the last time the update check was performed.

$(md '##') Operations:
$(git_hooks__extract_help)

$(md '##') Writing custom git hook scripts:
$(md_no_indent_or_hash "
    Once $(md_inline_quotes 'git-hooks install') has been called for your repository, creating and
    installing your own hooks is a simple matter of placing them in the newly-
    created $(md_inline_monospace '.githooks') directory. Your hooks must follow a particular naming
    convention:
")

$(md_block_monospace '       <standard git hook name>-<custom suffix>')
$(md_no_indent_or_hash "
    When a git hook is invoked it will look for your hooks scripts with the
    corresponding prefix and call them according to your config. By default
    your scripts will be run sequentially in alphabetical order as they appear
    in the $(md_inline_monospace '.githooks') directory.

    Setting the parallel option (see above) will cause all scripts to be run
    concurrently without regard to their conventional order.
")

$(md '###')    Preventing parallel execution:
$(md_no_indent_or_hash "
        If your script cannot be run in parallel with another of the same
        git hook family, you may enforce this by calling the exported function
        $(md_inline_quotes 'prevent-parallel') from within your script.

        Example:
")
$(md_block_monospace '
        #!/usr/bin/env bash
        prevent-parallel   # Will exit the hook with a non-zero exit code
                           # unless it is being run sequentially.
')

HELP


# Functions
#############################################

function git_hooks__extract_hook_names_from_man_page {
    man githooks 2>/dev/null | grep -E '^ {0,4}[-a-z]+$'
}


function git_hooks__require_git_dir {
    if [[ -z "$git_dir" ]]; then
        printf >&2 "${c_error}%s${c_reset}\\n" "Must be in a git repository"
        return 1
    fi
}


function git_hooks__ensure_hook_dir {
    mkdir -p "$githooks_dir"
}


function git_hooks__is_git_hook {
    local hook name="$1"
    for hook in "${git_hook_names[@]}"; do
        [[ "$hook" == "$name" ]] && return 0
    done
    return 1
}


function git_hooks__git_hook_prefix {
    local hook name="$1"
    for hook in "${git_hook_names[@]}"; do
        case "$name" in
            "${hook}"*) echo "$hook"; return 0 ;;
            *) ;;
        esac
    done
    return 1
}


function git_hooks__extract_desc {
    echo "$1 $(git_hooks__extract_doc -a "git_hooks_${1//-/_}" | sed 's/^\s*//g')"
}


function git_hooks__extract_help {
    local cmd
    while read -r cmd; do
        printf "\\n    %s\\n" "$(git_hooks__extract_desc "$cmd")"
        git_hooks__extract_doc -h "git_hooks_${cmd//-/_}" | sed 's/^/    /g'
    done < <(grep "\$(git_hooks__extract_desc [-a-z]\\+)\$" "${bash_source}" | sed 's/.* \(.*\))/\1/g')
}


function git_hooks__extract_doc {
    local doc_type

    eval set -- "$($getopt -o ah -- "$@")"
    while [[ "$1" != -- ]]; do
        case "$1" in
            -a) doc_type=ARGS; shift;;
            -h) doc_type=HELP; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    type "$1" | awk "NR==1,/<<-${doc_type}/{next}/^${doc_type}/,NR==0{next}{print}"
}


function git_hooks_help {
    : <<-ARGS
	    [--markdown]
	ARGS
    : <<-HELP
	    Displays this help message.

	    If --markdown is specified, the help message will be generated with
	    additional markdown syntax for headings and code blocks.
	HELP

    eval set -- "$($getopt -o m --long "markdown" -- "$@")"
    export USE_MARKDOWN=false;
    while [[ $1 != -- ]]; do
        case $1 in
            -m|--markdown)
                export USE_MARKDOWN=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift
    if [[ -n ${1:-} ]]; then
        printf "git hooks %s\\n" "$(git_hooks__extract_desc "$1")"
        echo
        git_hooks__extract_doc -h "git_hooks_${1//-/_}"
    else
        if [[ -t 1 ]]; then
            eval "echo \"$GITHOOKS_HELP\"" | less
        else
            eval "echo \"$GITHOOKS_HELP\""
        fi
    fi
}




function git_hooks_install {
    : <<-ARGS
	    [--no-preserve]
	ARGS
    : <<-HELP
	    Installs the multiplexer hooks into the .git/hooks directory.
	    These scripts are the core of the git-hooks functionality.
	    They are responsible for running any configured custom scripts
	    according to your specifications (sequential vs parallel,
	    disabled, etc.). This operation alse creates the .githooks
	    directory and moves any existing hooks into it. Any scripts
	    moved in this process will receive the "-moved" suffix.

	    If --no-preserve is specified, no existing hook scripts in
	    .git/hooks will be moved to the .githooks directory with the
	    "-moved" suffix.
	HELP

    local item preserve=true

    eval set -- "$($getopt -o "" --long "no-preserve" -- "$@")"
    while [[ ${1:-} != -- ]]; do
        case ${1:-} in
            --no-preserve) preserve=false; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    # Create the .git/hooks and .githooks directories
    mkdir -p "$repo_git_hooks_dir" "$githooks_dir"

    # Move existing hooks to .githooks dir
    # shellcheck disable=SC2015
    "$preserve" && printf "${c_action}%s ${c_value}%s${c_reset}\\n" "Moving existing hooks to" "$githooks_dir"
    shopt -s nullglob
    for item in "${repo_git_hooks_dir}/"*; do
        if ! [[ -h "$item" && "$(readlink "$item")" =~ git-hooks-multiplexer ]]; then
            if "$preserve"; then
                mv -v "$item" "${githooks_dir}/$(basename "$item")-moved" | sed "s/^/    /"
            else
                rm -f "$item"
            fi
        fi
    done
    shopt -u nullglob

    printf "${c_action}%s${c_reset}\\n" "Installing multiplexers"
    for hook in "${git_hook_names[@]}"; do
        item="${repo_git_hooks_dir}/${hook}"
        if ! [[ -h "$item" && "$(readlink "$item")" == "${bash_source_dir}/git-hooks-multiplexer" ]]; then
            ln -isv "${bash_source_dir}/git-hooks-multiplexer" "${repo_git_hooks_dir}/${hook}"
        fi
    done

    printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_value}%s ${c_action}%s${c_reset}\\n" \
        "Creating" ".githooks/config" "file and" ".githooks/.collections" "directory"
    mkdir -vp "${githooks_dir}/.collections"
    touch "${githooks_dir}/config"
    git add "${githooks_dir}/config"

    if [[ ! -f .gitignore ]] || ! grep -q "\\.githooks/\\.collections" ".gitignore"; then
        printf "${c_action}%s ${c_value}%s${c_reset}\\n" "Updating" ".gitignore"
        echo "$(basename "$githooks_dir")/.collections" >>.gitignore
        git add .gitignore
    fi
}




function git_hooks_add_collection {
    : <<-ARGS
	    <collection name> <clone url> [<subpath to hooks>]
	ARGS
    : <<-HELP
	    Configures this repository to be able to reference git hooks hosted
	    in a remote locatior (currently only supports git repositories).

	    <collection name>:  The internal name for the collection. Must be unique
	                        within this repository.

	    <clone url>:        The collection's remote url.

	    <subpath to hooks>: The collection-relative path to the hook directories.
	HELP
    local c_name="$1" c_type="git" c_location="$2" c_subpath="${3:-}"
    local git_hooks_config="${githooks_dir}/config"
    local collections_path="${githooks_dir}/.collections"

    mkdir -p "$githooks_dir"

    git config -f "$git_hooks_config" --unset-all collection.names "^${c_name}\$" &>/dev/null ||:
    git config -f "$git_hooks_config" --remove-section "collection.$c_name" &>/dev/null ||:
    rm -rf "${collections_path:?}/${c_name}"

    git config -f "$git_hooks_config" --add collection.names "$c_name"
    git config -f "$git_hooks_config" "collection.${c_name}.type" "$c_type"
    git config -f "$git_hooks_config" "collection.${c_name}.location" "$c_location"
    if [[ -n "$c_subpath" ]]; then
        git config -f "$git_hooks_config" "collection.${c_name}.subpath" "$c_subpath"
    fi
}




function git_hooks__sync_collection {
    local git_hooks_config="${githooks_dir}/config"
    local collections_path="${githooks_dir}/.collections"
    local c_name="$1" c_type c_location

    # Ensure we know about the collection
    git config -f "$git_hooks_config" --get collection.names "$c_name" &>/dev/null
    c_type=$(git config -f "$git_hooks_config" --get "collection.${c_name}.type")
    c_location=$(git config -f "$git_hooks_config" --get "collection.${c_name}.location")

    mkdir -p "$collections_path"
    case "$c_type" in
        git)
            if [[ -d "${collections_path}/${c_name}" ]]; then
                pushd "${collections_path}/${c_name}" &>/dev/null
                git pull &>/dev/null
                popd &>/dev/null
            else
                git clone "$c_location" "${collections_path}/${c_name}"
            fi
            ;;

        *)
            ;;
    esac
}





function git_hooks_uninstall {
    : <<-HELP
	    Removes the multiplexer hooks from the .git/hooks directory and
	    removes the 'git-hooks' symlink from /usr/local/bin, if present.
	HELP

    printf "${c_action}%s${c_reset}\\n" "Removing multiplexers"
    for hook in "${repo_git_hooks_dir}/"*; do
        if [[ -h "$hook" && "$(readlink "$hook")" =~ git-hooks-multiplexer ]]; then
            rm -v "$hook"
        fi
    done
}




# shellcheck disable=SC2120
function git_hooks_install_command {
    : <<-ARGS
	ARGS
    : <<-HELP
	    Creates a symlink to 'git-hooks' in /usr/local/bin
	HELP

    if ! ln -isv "${bash_source}" "/usr/local/bin"; then
        printf >&2  "${c_action}%s ${c_value}%s${c_reset}" "Could not link to" "/usr/local/bin/git-hooks"
        return 1
    fi
}




# shellcheck disable=SC2120
function git_hooks_uninstall_command {
    : <<-ARGS
	ARGS
    : <<-HELP
	    Removes the symlink to 'git-hooks' in /usr/local/bin, if present.
	HELP

    rm -f /usr/local/bin/git-hooks
}




function git_hooks_install_template {
    : <<-HELP
	    Installs the multiplexer scripts into ~/.gittemplate/hooks (or
	    into the location defined by the init.templateDir config value).
	    This will cause any subsequently cloned or created repositories to
	    automatically populate their .git/hooks directories with the
	    multiplexer script.

	    To update previously cloned repositories, just run 'git init' again.
	HELP

    local templatedir

    if ! templatedir="$(git config --global init.templateDir)"; then
        templatedir=~/.gittemplate
        printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_reset}\\n" "Setting" "init.templateDir = $templatedir" "in your global git config"
        git config --global --path init.templateDir "$templatedir"
    fi

    printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_reset}\\n" "Adding multiplexer hooks to" "${templatedir}/hooks" "directory"
    mkdir -p "${templatedir}/hooks"
    pushd "${templatedir}/hooks" >/dev/null
    for hook in "${git_hook_names[@]}"; do
        if ! [[ -h "$hook" && "$(readlink "$hook")" == "${bash_source_dir}/git-hooks-multiplexer" ]]; then
            ln -isv "${bash_source_dir}/git-hooks-multiplexer" "$hook"
        fi
    done
    popd >/dev/null

    cat <<-EOF

	    These multiplexer hooks will now be installed on any new repos created or cloned on this system.
	    To enable hooks for already existing repos, run 'git init' in those repos again.
	EOF

    mkdir -p "${templatedir}/info"
    echo ".githooks/.collections" >"${templatedir}/info/exclude"
}




function git_hooks_uninstall_template {
    : <<-HELP
	    Undoes the effects of 'install-template'.
	HELP
    local templatedir
    if templatedir="$(git config --global init.templateDir)"; then
        if [[ -d "${templatedir}/hooks" ]]; then
            printf "${c_action}%s ${c_value}%s ${c_action}%s${c_reset}\\n" "Removing multiplexer hooks from" "${templatedir}/hooks" "directory"
            pushd "${templatedir}/hooks" >/dev/null

            for hook in "${git_hook_names[@]}"; do
                [[ -h "$hook" ]] && rm -i "$hook"
            done

            popd >/dev/null
        fi
    fi
}




function git_hooks_check_support {
    : <<-HELP
	    Checks for differences in the list of hooks supported by
	    git-hooks and the list of hooks supported by git. If differences
	    are present, consider upgrading git-hooks or git.
	HELP
    local -a documented_hook_names
    # shellcheck disable=SC2207
    documented_hook_names=( $(git_hooks__extract_hook_names_from_man_page) )

    local known=("$(
        comm --nocheck-order -23 \
            <(echo "${git_hook_names[@]}" | xargs -n1 | sort) \
            <(echo "${documented_hook_names[@]}" | xargs -n1 | sort)
    )")
    local found=("$(
        comm --nocheck-order -13 \
            <(echo "${git_hook_names[@]}" | xargs -n1 | sort) \
            <(echo "${documented_hook_names[@]}" | xargs -n1 | sort)
    )")

    if [[ -n "${known[*]}" ]]; then
        printf "${c_action}%s${c_reset}\\n" "These hooks are not supported by your current version of git:"
        echo "${known[@]}" | xargs -n1 | sed 's/^/    /'
        echo
    fi

    if [[ -n "${found[*]}" ]]; then
        printf "${c_action}%s${c_reset}\\n" "These hooks are not yet supported by git-hooks:"
        echo "${found[@]}" | xargs -n1 | sed 's/^/    /'
        echo
    fi

    if [[ -z "${known[*]}" && -z "${found[*]}" ]]; then
        printf "${c_action}%s${c_reset}\\n" "All hooks are currently supported"
    fi
}




# shellcheck disable=SC2120
function git_hooks_list {
    : <<-ARGS
	    [<git hook>...]
	ARGS
    : <<-HELP
	    List all hooks for the current repository and their runnable state.
	HELP

    local total count disabled unicode hook_name previous_hook_name hooks_list max_len=0 padding pad

    unicode="$(git config --bool git-hooks.unicode)" || unicode=true

    hooks_list="$(git_hooks__get_hooks "$@")"
    while read -r _ hook_name _ _; do
        max_len=$(( ${#hook_name}>max_len ? ${#hook_name} : max_len ))
    done <<<"$hooks_list"

    while read -r total hook_name hook hook_path; do
        echo -en "${c_reset}"
        if [[ "${previous_hook_name:-}" != "${hook_name}" ]]; then
            previous_hook_name="$hook_name"
            count=0

            git config --get-regexp "hooks\\.$hook_name\\.enabled" false &>/dev/null && disabled=true || disabled=false

            [[ -n "${previous_hook_name:-}" ]] && echo
            "$disabled" && echo -en "${c_error}"
            "$unicode" && padding="────────────────────" || padding="--------------------"
            pad=${padding:0:$(( max_len - ${#hook_name} + 1 ))}
            "$unicode" && echo -en "${hook_name}${pad}┐${c_reset}" || echo -en "${hook_name}${pad}|${c_reset}"
            "$disabled" && echo " (disabled)" || echo
        fi

        "$disabled" && connector="${c_error}" || connector=""
        if ((++count < total)); then
            "$unicode" && connector+="├─" || connector+="|-"
        else
            "$unicode" && connector+="└─" || connector+="|-"
        fi

        # shellcheck disable=2091
        if git config --get-regexp "hooks\\.${hook_name}-${hook}\\.enabled" false &>/dev/null; then
            printf " %${max_len}s${connector}${c_error}%s${c_reset} (disabled)\\n" "" "${hook}"
        elif "$disabled";then
            printf " %${max_len}s${connector}${c_error}%s${c_reset} (disabled by $hook_name)\\n" "" "${hook}"
        elif [[ -f "$hook_path" ]]; then
            if [[ -x "$hook_path" ]]; then
                printf " %${max_len}s${connector}%s${c_reset}\\n" "" "${hook}"
            else
                printf " %${max_len}s${connector}${c_error}%s${c_reset} (not executable)\\n" "" "${hook}"
            fi
        else
            printf " %${max_len}s${connector}${c_missing}%s${c_reset} (not found)\\n" "" "${hook}"
        fi
    done <<<"$hooks_list"
}

function git_hooks__get_hooks {
    local -a hook_names=( "${@:-${git_hook_names[@]}}" )
    local hook_name total path name
    # local hook_scripts hook_script
    # hook name path normalized disabled count total unicode connector

    [[ -d "$githooks_dir" ]] || return

    for hook_name in "${hook_names[@]}"; do
        if ! git_hooks__is_git_hook "$hook_name"; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Not a valid git hook name:" "$hook_name"
            continue
        fi

        total=$(find "$githooks_dir" -type f -path "*/${hook_name}*" -not -path "*/.collections/*" -not -name "*~" | wc -l)

        while read -r path; do
            name="${path##*${hook_name}}"
            name="${name:1:${#name}}"
            echo "$total $hook_name $name $path"
        done < <(find "$githooks_dir" -type f -path "*/${hook_name}*" -not -path "*/.collections/*" -not -name "*~")
    done
}





function git_hooks_enable {
    : <<-ARGS
	    [-q|--quiet] <git hook>... <custom script name>...
	ARGS
    : <<-HELP
	    Enables a script (or scripts) to be run during git hook
	    invocation. Scripts are enabled by default.

	    If --quiet is specified, the updated enabled state of all hook
	    scripts will not be displayed.
	HELP

    local name quiet=false

    eval set -- "$($getopt -o q --long "quiet" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -q|--quiet) quiet=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    for name in "$@"; do
        git config --unset "hooks.$name.enabled" ||:
    done

    if ! "$quiet"; then
        # shellcheck disable=SC2119
        git_hooks_list
    fi
}




function git_hooks_disable {
    : <<-ARGS
	    [-q|--quiet] <git hook>... <custom script name>...
	ARGS
    : <<-HELP
	    Prevents a script from being run during git hook invocation.

	    If --quiet is specified, the updated enabled state of all hook
	    scripts will not be displayed.
	HELP

    local name quiet=false

    eval set -- "$($getopt -o q --long "quiet" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -q|--quiet) quiet=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    for name in "$@"; do
        git config --bool "hooks.$name.enabled" false
    done

    if ! "$quiet"; then
        # shellcheck disable=SC2119
        git_hooks_list
    fi
}




function git_hooks_run {
    : <<-ARGS
	    [-f|--force] <git hook>|<custom script name>
	ARGS
    : <<-HELP
	    Runs a git hook or an individual custom script. stdin and any
	    extra arguments will be forwarded to the designated target.

	    This command respects the enabled/disabled state of the hooks and
	    scripts. You can force the hook or script to run by specifying the
	    --force flag.
	HELP
    local hook name path

    eval set -- "$($getopt -o f --long "force" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -f|--force) export GITHOOKS_RUN=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    if [[ -z ${1:-} ]]; then
        printf >&2 "${c_error}%s${c_reset}\\n" "Must provide a git hook or custom script name:"
        # shellcheck disable=SC2119
        git_hooks_list
        return 1
    elif git_hooks__is_git_hook "$1"; then
        hook="$1"
    elif hook=$(git_hooks__git_hook_prefix "$1"); then
        name="$1"
    else
        printf >&2 "${c_error}%s${c_reset}\\n" "Not a valid git hook or custom script name"
        return 1
    fi
    shift ||:

    # Verify the presence of expected arguments
    case "$hook" in
        applypatch-msg) [[ $# == 1 ]] || { echo >&2 "Missing 1 parameter"; return 1; };;
        commit-msg) [[ $# == 1 ]] || { echo >&2 "Missing 1 parameter"; return 1; };;
        prepare-commit-msg) [[ $# == 1 ]] || { echo >&2 "Missing 1 parameters"; return 1; };;
        update) [[ $# == 3 ]] || { echo >&2 "Missing 3 parameters"; return 1; };;
        pre-receive|post-receive) [[ -t 0 ]] && { echo >&2 "Expected contents on stdin"; return 1; };;
    esac

    # Locate the hook or script path
    if [[ -z "${name:-}" ]];then
        # Run the multiplexer script
        path="${repo_git_hooks_dir}/${hook}"
    else
        if [[ -f "${githooks_dir}/${name}" ]]; then
            path="${githooks_dir}/${name}"
        elif [[ -f "${githooks_dir}/${hook}/${name#${hook}-}" ]]; then
            path="${githooks_dir}/${hook}/${name#${hook}-}"
        else
            printf >&2 "${c_error}%s${c_reset}\\n" "Could not find hook or custom script"
            return 1
        fi

        if [[ ! -f "$path" ]]; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook does not exist:" "$path"
            return 1
        elif [[ ! -x "$path" ]]; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook is not executable:" "$path"
            return 1
        fi
    fi

    pushd "$top_dir" >/dev/null
    "$path" "$@"
    popd >/dev/null
}




function git_hooks_parallel {
    : <<-ARGS
	    <git hook> [<num>]
	ARGS
    : <<-HELP
	    Modify the hooks.<git hook>.parallel config setting. <num> should
	    be the desired number of jobs to spawn when running the hook
	    scripts. If the second argument is not provided, it will display
	    the current setting. If <num> is 'max', it will be interpreted as
	    the number of CPUs as seen by cpuid. If <num> is "-", the current
	    setting will be cleared and the hook will not be run in parallel
	    mode.

	    When running in parallel, each script's output is buffered until
	    it finishes. When complete, the output will be written to stdout.
	HELP

    local hook_name="${1:-}" num="${2:-}"
    shift || { printf >&2 "${c_error}%s${c_reset}\\n" "Missing git hook name"; return 1; }

    if ! git_hooks__is_git_hook "$hook_name"; then
        printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Not a valid git hook name:" "$hook_name"
        return 1
    fi

    case $hook in
        -) git config --unset "hooks.${hook_name}.parallel" ||:;;
        *) git config "hooks.${hook_name}.parallel" "$num" ||:;;
    esac
}




function git_hooks_show_input {
    : <<-ARGS
	    <git hook> [true|false]
	ARGS
    : <<-HELP
	    Modify the hooks.<git hook>.showinput config setting. If no value
	    is provided, it will display the current setting. If this setting
	    is true, the received arguments and stdin will be displayed during
	    git hook invocation.
	HELP

    local hook_name="${1:-}" show="${2:-}"
    shift || { printf >&2 "${c_error}%s${c_reset}\\n" "Missing git hook name"; return 1; }

    if ! git_hooks__is_git_hook "$hook_name"; then
        printf >&2 "${c_error}%s${c_reset}\\n" "First argument must be a valid git hook name"
        return 1
    fi

    case "$show" in
        true|false|"") ;;
        *) printf >&2 "${c_error}%s${c_reset}\\n" "Second argument must be true, false or omitted"; return 1;;
    esac

    if [[ -n "$show" ]] && ! "$show"; then
        git config --unset "hooks.${hook_name}.showinput" ||:
    else
        git config --bool "hooks.${hook_name}.showinput" "$show" || echo false
    fi
}




function git_hooks_config {
    : <<-HELP
    Simply lists all hooks-related git config settings.
HELP

    local -a files=( system global )

    if git_hooks__require_git_dir; then
        files=( "${files[@]}" local )
    fi

    for location in "${files[@]}"; do
        printf "${c_action}%s${c_reset}\\n" "[$location]"
        git config "--$location" --get-regexp hooks ||:
        echo
    done
}




function git_hooks_include {
    : <<-ARGS
	    <collection name> <git hook> <hook executable> [<new name>]
	ARGS
    : <<-HELP
	    Link an existing script from a collection into this repository.
	    If <new name> is provided, that name will be used instead of <hook script>
	    for the reference file installed into the repository. This is useful when one
	    wishes to specify a strict order to in which to run multiple scripts for
	    <git hook>. Just provide a numeric prefix on the <new name> to indicate
	    the script's place in the running order.
	HELP
    local git_hooks_config="${githooks_dir}/config"
    local collections_path="${githooks_dir}/.collections"
    local c_name="$1" hook_name="$2" hook="$3" as="${4:-}" c_location c_subpath="" c_subpath_tmp src_path path

    # Ensure we know about the collection
    git config -f "$git_hooks_config" --get collection.names "$c_name" &>/dev/null
    c_location=$(git config -f "$git_hooks_config" --get "collection.${c_name}.location")

    git_hooks__sync_collection "$c_name"
    git_hooks__ensure_collection "$c_name"

    # Check the collection repo first, then allow overrides from local repo
    if c_subpath_tmp=$(git config -f "${collections_path}/${c_name}/.git-hooks-collection" --get "collection.subpath") 2>/dev/null; then
        c_subpath="$c_subpath_tmp"
    fi
    if c_subpath_tmp=$(git config -f "$git_hooks_config" --get "collection.${c_name}.subpath") 2>/dev/null; then
        c_subpath="$c_subpath_tmp"
    fi

    src_path="${collections_path}/${c_name}/${c_subpath:+${c_subpath}/}${hook_name}/${hook}"
    if [[ -f "$src_path" ]]; then
        if [[ ! -x "$src_path" ]]; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook not executable:" "$src_path"
            return 1
        fi

        path="${githooks_dir}/${hook_name}/${as:-${hook}}"
        mkdir -p "$(dirname "$path")"
        printf '#!/usr/bin/env git-hooks\n\n' > "$path"
        git config -f "$path" git-hooks.collection "$c_name"
        git config -f "$path" git-hooks.hook "${hook_name}/${hook}"
        chmod +x "$path"
        printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_value}%s${c_reset}\\n" \
            "Linked" "${path#*\.githooks/}" "to" "${src_path#${collections_path}/}"
    else
        printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook not found:" "$src_path"
    fi
}




function git_hooks__check_for_updates {
    last_check="$(git config --global git-hooks.last-check 2>/dev/null)" || last_check=0
    if (( "$(date -v "-7d" "+%s" 2>/dev/null || date -d "last week" "+%s")" > last_check )); then
        (
            cd "$bash_source_dir";
            git fetch &>/dev/null;
            behind="$(git rev-list HEAD..origin/master | wc -l)";
            if (( behind )); then
                printf "${c_action}%s ${c_value}%s ${c_action}%s${c_reset}\\n" \
                    "git-hooks is" "$behind" "commits behind. Consider pulling latest code."
            fi
        )
        git config --global git-hooks.last-check "$(date "+%s")"
    fi
}


# Globals
#############################################

# Populated in _verify_dirs
git_dir="$(git rev-parse --git-dir 2>/dev/null)" || git_dir=""
repo_dir="$(git rev-parse --show-toplevel 2>/dev/null)" || repo_dir=""
repo_is_bare="$(git rev-parse --is-bare-repository 2>/dev/null)" || repo_is_bare=false
if "$repo_is_bare"; then
    top_dir="$git_dir"
    repo_git_hooks_dir="$(git config core.hooksPath || echo "${git_dir}/hooks")"
    githooks_dir="${top_dir}/.githooks"
elif [[ -n "$repo_dir" ]]; then
    top_dir="$repo_dir"
    repo_git_hooks_dir="$(git config core.hooksPath || echo "${git_dir}/hooks")"
    githooks_dir=${top_dir}/.githooks
else
    top_dir=
    repo_git_hooks_dir=
    githooks_dir=
fi

# Main functionality
#############################################
function git_hooks__main {
    # Ensure we have prerequisite tools
    git_hooks__ensure_modern_bash
    git_hooks__ensure_gnu_getopt

    # What command were we given?
    git_hooks_command="${1:-list}"; shift ||:

    # Determine the correct command to run and pass it the rest of the un-parsed options
    case "$git_hooks_command" in
        # Require a git repository and a .githooks directory in the repository for these commands
        list|include|disable|enable|run|parallel|show-input)
            git_hooks__require_git_dir
            git_hooks__ensure_hook_dir
            ;;

        # Require a git repository but not a .githooks directory in the repository
        install|uninstall)
            git_hooks__require_git_dir
            ;;

        add-collection|sync-collection|check-support|install-command|uninstall-command|install-template|uninstall-template|config|help)
            ;;

        *)  printf >&2 "${c_error}%s ${c_value}%s ${c_error}%s${c_reset}\\n" "git-hooks:" "$git_hooks_command" "is not a git-hooks command." >&2
            exit 1
            ;;
    esac

    "git_hooks_${git_hooks_command//-/_}" "$@"
}

# "#!/usr/bin/env git-hooks" functionality
#############################################
function git_hooks__run_referenced_hook {
    # This function executes a "script" created by the "git hooks include" command
    local hook_path collection_name collection_subpath

    hook_path="$1"
    shift

    collection_name="$(git config -f "$hook_path" --get git-hooks.collection)"
    collection_subpath="$(git config -f "${githooks_dir}/config" --get "collection.${collection_name}.subpath")" ||:

    # Retrieve/update the collection referenced in this config
    git_hooks__sync_collection "$collection_name"
    git_hooks__ensure_collection "$collection_name"

    "${githooks_dir}/.collections/${collection_name}/${collection_subpath:+${collection_subpath}/}$(git config -f "$hook_path" --get git-hooks.hook)" "$@"
}

# Determine if this file is being sourced or invoked
unset BASH_SOURCE 2>/dev/null ||:
# shellcheck disable=2015
if [[ ".$0" == ".${BASH_SOURCE[0]}" ]]; then
    # If we're here, this file is being run, not sourced

    # Determine if it was run as the interpreter for #!/usr/bin/env git-hook scripts
    # or just run as a direct call.
    if [[ -n "${1:-}" && "${invocation}" == "$1" ]]; then
        # This is the "interpreter" mode. This happens when one of the "include"
        # configurations is run.

        git_hooks__run_referenced_hook "$@"
    else
        git_hooks__main "$@" ||:
    fi
fi

