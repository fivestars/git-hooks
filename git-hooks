#!/usr/bin/env bash
invocation="${_:-}"
set -eu -o pipefail

# Borrowed from https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
unset CDPATH
bash_source="${BASH_SOURCE[0]}"
while [[ -h "$bash_source" ]]; do
    bash_source_dir="$(cd -P "$(dirname "$bash_source")" >/dev/null && pwd)"
    bash_source="$(readlink "$bash_source")"
    [[ "$bash_source" != /* ]] && bash_source="${bash_source_dir}/${bash_source}"
done
bash_source_dir="$(cd -P "$(dirname "$bash_source")" >/dev/null && pwd)"
bash_source="${bash_source_dir}/${bash_source##*/}"

# shellcheck disable=1090
. "${bash_source_dir}/included/lib/colors.sh" "${bash_source_dir}/included/lib"

color="$(git config --bool git-hooks.color)" || color=true
if "$color" &>/dev/null; then
    c_action="${c_action:-${cyan}}"
    c_prompt="${c_prompt:-${b_cyan}}"
    c_value="${c_value:-${yellow}}"
    c_error="${c_error:-${red}}"
    c_warning="${c_warning:-${b_red}}"
    c_missing="${c_missing:-${b_black}}"
else
    c_action=""
    c_prompt=""
    c_value=""
    c_error=""
    c_warning=""
    c_missing=""
    c_reset=""
fi

# Hard-coded here for speed, but might get out of sync with actual supported
# hooks if git gets new hooks in future versions. See check-support for details.
git_hook_names=(
    applypatch-msg
    commit-msg
    fsmonitor-watchman
    post-applypatch
    post-checkout
    post-commit
    post-merge
    post-receive
    post-rewrite
    post-update
    pre-applypatch
    pre-auto-gc
    pre-commit
    pre-push
    pre-rebase
    pre-receive
    prepare-commit-msg
    push-to-checkout
    sendemail-validate
    update
)



function git_hooks__ensure_modern_bash {
    # Ensure that the user has a modern version (>= 4.*) of the bash shell (silly mac users)
    case "${BASH_VERSION}" in
        4.*) ;;
        5.*) ;;
        *)  printf >&2 "${c_error}%s${c_reset}\\n" "Upgrade your bash to version 4.*"
            exit 1
            ;;
    esac
}


function git_hooks__ensure_gnu_getopt {
    # We depend on GNU getopt for option parsing, but we don't expect
    # OSX users to install it over their built-in getopt command.
    set +e
    getopt -T &>/dev/null
    if [[ $? -eq 4 ]]; then
        getopt=getopt
    elif brew --prefix gnu-getopt &>/dev/null; then
        getopt=$(brew --prefix gnu-getopt)/bin/getopt
    elif command -v port &>/dev/null; then
        getopt=/opt/local/bin/getopt
    else
        printf >&2 "${c_error}%s${c_reset}\\n" "Install GNU getopt (see README)"
        exit 1
    fi

    # Final check because 'brew --prefix' can return a path that points to nothing.
    if ! command -v $getopt &>/dev/null; then
        printf >&2 "${c_error}%s${c_reset}\\n" "Could not find GNU getopt"
        exit 1
    fi
    set -e
}

function git_hooks__sync_collection {
    git_hooks__ensure_gnu_getopt

    local hooks_dir="$githooks_dir" force=""
    eval set -- "$($getopt -o gf --long "global, force" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -g|--global) hooks_dir="$global_githooks_dir"; shift;;
            -f|--force) force="--force"; shift;;
        esac
    done
    shift

    local git_hooks_config="${hooks_dir}/config"
    local collections_path="${hooks_dir}/.collections"
    local c_name="$1" c_type c_location c_path c_config_file

    # Ensure we know about the collection
    git config -f "$git_hooks_config" --get collection.names "$c_name" &>/dev/null
    c_type=$(git config -f "$git_hooks_config" --get "collection.${c_name}.type")
    c_location=$(git config -f "$git_hooks_config" --get "collection.${c_name}.location")

    mkdir -p "$collections_path"
    case "$c_type" in
        git)
            c_path="${collections_path}/${c_name}"
            c_config_file="${c_path}/.git/config"

            if [[ -f "$c_config_file" ]]; then
                git_hooks__update_if_needed "$force" "$c_path"
            else
                git clone "$c_location" "$c_path"
            fi
            ;;

        *)
            ;;
    esac
}

function git_hooks__ensure_collection {
    git_hooks__ensure_gnu_getopt

    local hooks_dir="$githooks_dir"

    eval set -- "$($getopt -o g --long "global" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -g|--global) hooks_dir="$global_githooks_dir"; shift;;
        esac
    done
    shift

    local collections_path="${hooks_dir}/.collections"
    local c_name="$1"

    [[ -d "${collections_path}/${c_name}" ]]
    (pushd "${collections_path}/${c_name}" &>/dev/null; git rev-parse --is-inside-work-tree &>/dev/null)
}

# Utility functions for README.md
function md {
    if $USE_MARKDOWN; then
        echo -n "$@"
    fi
}

function md_omit {
    if ! $USE_MARKDOWN; then
        echo -n "$@"
    fi
}

function md_inline_quotes {
    if $USE_MARKDOWN; then
        echo -n "\`$*\`"
    else
        echo -n "'$*'"
    fi
}

function md_inline_bold {
    if $USE_MARKDOWN; then
        echo -n "**$***"
    else
        echo -n "$*"
    fi
}

function md_inline_monospace {
    if $USE_MARKDOWN; then
        echo -n "\`$*\`"
    else
        echo -n "$@"
    fi
}

function md_block_monospace {
    if $USE_MARKDOWN; then
        echo -e "\`\`\`$*\\n\`\`\`"
    else
        echo "$@"
    fi
}

function md_no_indent_or_hash {
    if $USE_MARKDOWN; then
        sed 's/^[ \t]*[#]*[ \t]*//' <<< "$@" | tr '\n' ' '
    else
        echo "$@"
    fi
}


# HELP
#############################################
read -r -d '' GITHOOKS_HELP <<'HELP' ||:
$(md '# git-hooks')
$(md_omit "git-hooks - ")A tool for managing and invoking custom git hook scripts.

$(md '##') Description:
$(md_no_indent_or_hash "
    $(md_inline_bold git-hooks) is a tool to facilitate git hook management, specifically being
    able to store your hooks under source control within the repository itself
    and simply reference them from a multiplexer hook installed in the
    $(md_inline_monospace .git/hooks) directory.
")

$(md_no_indent_or_hash "
    The expected usage is to write an arbitrary number of individual hook
    scripts associated with a single standard git hook and store them in the
    $(md_inline_monospace '.githooks') directory. When git invokes the multiplexer script in $(md_inline_monospace .git/hooks),
    it will call your custom scripts sequentially, or in parallel if you
    configure it to do so.
")

$(md_no_indent_or_hash "
    This way you can break your monolithic hooks into individual files, giving
    you greater flexibility regarding which pieces to run and when.
")

$(md '##') Features:

$(md '###') Run your hooks directly:
$(md_no_indent_or_hash "
    $(md_inline_bold git-hooks) allows you to invoke your hook scripts without being triggered by
    a git action. This is useful for speeding up the process of debugging issues
    that caused your hooks to fail in the first place. If you write your hook
    scripts well, you can even pass extra arguments to your scripts that wouldn't
    be present when being run from a git trigger. (eg. specifying a particular
    unit test to speed up debugging).
")

$(md '###') Disable/enable particular hooks or hook scripts:
$(md_no_indent_or_hash "
    $(md_inline_bold git-hooks) gives you the ability to disable hooks down to the individual script
    level. So if something is preventing a particular script from succeeding and
    can be temporarily ignored, you can just disable that one and the other scripts
    for that trigger will still apply. This is much better than $(md_inline_monospace --no-verify).
")

$(md '###') Hook repositories:
$(md_no_indent_or_hash "
    Rather than copying and pasting the same hook code into each of your
    repositories, you can create a shared collection of hooks (as a git repo) and
    simply reference those from within your repository. This way, as your hook
    functionality evolves, you only need to push the code to the collection's
    repo, and $(md_inline_bold git-hooks) will ensure that you pull down the latest.
")

$(md '###') Global hooks:
$(md_no_indent_or_hash "
    You can have "global hooks" on your machine. These will be run for any
    repository that has $(md_inline_bold git-hooks) installed (ie. has the multiplexer scripts
    in its $(md_inline_monospace .git/hooks) dir. See $(md_inline_bold Installation) below). This
    is useful for applying consistent, project-agnostic rules across all of
    your projects (such as commit message format/structure). These hooks can
    be literal script files or reference hooks, but they will not be checked
    into the source control of the repositories that they will affect. They
    will appear and run alongside the repo's own hooks.
")

$(md_no_indent_or_hash "
    Global hooks will be enabled by default for all repos with $(md_inline_bold git-hooks)
    installed. If you wish to prevent the global git hooks from running for
    a repostiory, set the local git config value of $(md_inline_quotes "git-hooks.global-enabled")
    to $(md_inline_quotes false) within the repository. This will allow you to continue
    to use the repo's source-controlled git hooks.
")

$(md '##') Installation:

$(md '#### ')$(md_no_indent_or_hash "    # Install GNU getopt (if not already present for your platform).")
$(md_block_monospace '
    getopt -T
    if [[ $? -ne 4 ]]; then
        brew install gnu-getopt
        # -- or --
        sudo port install getopt
    fi
')

$(md '#### ')$(md_no_indent_or_hash "    # Install $(md_inline_quotes 'git hooks')")
$(md_no_indent_or_hash "
    # This will symlink $(md_inline_monospace git-hooks) to $(md_inline_monospace /usr/local/bin).
    # This allows $(md_inline_monospace git) to treat it as a first-class command. In other words,
    # you can invoke its behavior via $(md_inline_quotes git hooks ...).
")
$(md_block_monospace '
    path/to/git-hooks/git-hooks install-command
')

$(md '#### ')$(md_no_indent_or_hash "    # Install the multiplexers for all new repos (cloned or init'ed)")
$(md_no_indent_or_hash "
    # This will make it so that you never have to run $(md_inline_quotes 'git hooks install')
    # again for this machine. This is useful when your repositories already
    # have a $(md_inline_monospace '.githooks') directory with hook scripts in it or if you plan to
    # make regular use of the $(md_inline_quotes 'git hooks') functionality in other or future
    # repositonies. Be sure to run $(md_inline_quotes 'git hooks install') in any repositories
    # that existed prior to installing the template configuration, as they
    # will still need to be setup with the multiplexer scripts.
")
$(md_block_monospace '
    git hooks install-template
')

$(md '#### ')$(md_no_indent_or_hash "    # Manually install the multiplexers into a repository")
$(md_no_indent_or_hash "
    # If you choose to not use the template configuration, you can still
    # install $(md_inline_monospace git-hooks) support manually on a per-repostory basis.
")
$(md_block_monospace '
    cd <to your repo>
    git hooks install
')

$(md '##') Updates:
$(md_no_indent_or_hash "
    $(md_inline_bold git-hooks) will periodically check for updates to the core tool and any added
    collections. You can manually check for updates with the $(md_inline_monospace update) and $(md_inline_monospace sync-collection)
    commands.
")

$(md '##') Usage:
        git hooks  # equivalent to list
    or: git hooks $(git_hooks__extract_desc list)
    or: git hooks $(git_hooks__extract_desc enable)
    or: git hooks $(git_hooks__extract_desc disable)
    or: git hooks $(git_hooks__extract_desc run)
    or: git hooks $(git_hooks__extract_desc install)
    or: git hooks $(git_hooks__extract_desc uninstall)
    or: git hooks $(git_hooks__extract_desc install-command)
    or: git hooks $(git_hooks__extract_desc uninstall-command)
    or: git hooks $(git_hooks__extract_desc install-template)
    or: git hooks $(git_hooks__extract_desc uninstall-template)
    or: git hooks $(git_hooks__extract_desc add-collection)
    or: git hooks $(git_hooks__extract_desc list-collections)
    or: git hooks $(git_hooks__extract_desc sync-collection)
    or: git hooks $(git_hooks__extract_desc include)
    or: git hooks $(git_hooks__extract_desc check-support)
    or: git hooks $(git_hooks__extract_desc parallel)
    or: git hooks $(git_hooks__extract_desc show-input)
    or: git hooks $(git_hooks__extract_desc config)
    or: git hooks $(git_hooks__extract_desc help)

$(md '##') Common Arguments:
    <path>...
        The command accepts a list of path strings.

    <git hook>...
        The command accepts a list of git hook names. These names should only
        include the names of the standard git hooks:

$(echo ${git_hook_names[@]} | xargs -L1 -n1 | sed 's/^/            /g')

    <custom script name>...
        The command accepts a list of hook script names. These names must
        indicate scripts in the repo's .githooks directory. Standard git hook
        names are not considered valid items in this list.

$(md '##') Files:
    .githooks/
        This is where git-hooks will look for default hook scripts. Place your
        hook scripts in here rather than .git/hooks. Your hook scripts should
        be executable and follow the naming convention:

            <standard git hook name>-<custom suffix>[.<file extension>]

        They will be executed in alphabetical order, so if you wish to control
        the order of execution, take that into account when naming the files.

        Examples: .githooks/pre-commit-00-style.sh
                  .githooks/pre-commit-01-unittest.py

    .git/config
        git-hooks config settings will be stored in your repository's config
        file. In the case of a bare repository, the config file is located at
        ./config.

    ~/.gitconfig
        Some configs, such as unicode output and color output support will be stored here.
        Additionally, the periodic update check information is stored here.

    ~/.gittemplate/hooks
    ~/.gittemplate/info/exclude
        These files will be updated if you choose to install the hooks into your
        repository template by running 'git hooks install-template'.

$(md '##') Configuration:
    Set these git config values (recommended that you use --global) to modify git-hooks behavior.

    git-hooks.unicode [default=true]
        Use unicode glyphs in certain operations' output (eg. git-hooks list)
        If false, standard ascii characters will be used instead

    git-hooks.color [default=true]
        Use colorized output.

$(md '##') Operations:
$(git_hooks__extract_help)

$(md '##') Writing custom git hook scripts:
$(md_no_indent_or_hash "
    Creating and installing your own hooks is a simple matter of placing them
    in your repository's $(md_inline_monospace '.githooks') directory. If you only have one or two hook
    scripts, you can use the $(md_inline_monospace '<standard git hook name>-<custom suffix>') naming
    convention. If you desire a little more organizational structure, you can
    create subdirectories in the $(md_inline_monospace '.githooks') directory corresponding to the
    standard git hook names and place your scripts within those. For example:
")
$(md_block_monospace '
    <your repo>/
        .githooks/
            commit-msg/
                format-check
            pre-commit/
                style-check
                unit-tests
')
$(md_no_indent_or_hash "
    When a git hook is invoked it will look for your hooks scripts with the
    corresponding prefix and call them according to your config. By default
    your scripts will be run sequentially in alphabetical order as they appear
    in the $(md_inline_monospace '.githooks') directory.

    Setting the parallel option (see above) will cause all scripts to be run
    concurrently without regard to their conventional order.
")
$(md '###')    Using included lib functionality:
$(md_no_indent_or_hash "
        There are some helpful functions already available to you in $(md_inline_monospace included/lib).
        If you wish to use them, you will need to $(md_inline_monospace source) the desired file. To
        facilitate this, your scripts will have access to the $(md_inline_monospace GIT_HOOKS_LIB) environment
        variable. For example, if you wanted to use $(md_inline_monospace commit_in_progress) you would do
        the following:
")
$(md_block_monospace '
        #!/usr/bin/env bash
        . "${GIT_HOOKS_LIB}/core.sh" "${GIT_HOOKS_LIB}"

        if ! commit_in_progress; then
            ...
        fi
')
$(md '###')    Preventing parallel execution:
$(md_no_indent_or_hash "
        If your script cannot be run in parallel with another of the same
        git hook family, you may enforce this by calling the exported function
        $(md_inline_quotes 'prevent-parallel') from within your script.

        Example:
")
$(md_block_monospace '
        #!/usr/bin/env bash
        prevent-parallel   # Will exit the hook with a non-zero exit code
                           # unless it is being run sequentially.
')

HELP


# Functions
#############################################

function git_hooks__extract_hook_names_from_man_page {
    man githooks 2>/dev/null | grep -E '^ {0,4}[-a-z]+$'
}


function git_hooks__require_git_dir {
    if [[ -z "$git_dir" ]]; then
        printf >&2 "${c_error}%s${c_reset}\\n" "Must be in a git repository"
        return 1
    fi
}


function git_hooks__is_git_hook {
    local hook name="$1"
    for hook in "${git_hook_names[@]}"; do
        [[ "$hook" == "$name" ]] && return 0
    done
    return 1
}


function git_hooks__git_hook_prefix {
    local hook name="$1"
    for hook in "${git_hook_names[@]}"; do
        case "$name" in
            "${hook}"*) echo "$hook"; return 0 ;;
            *) ;;
        esac
    done
    return 1
}


function git_hooks__extract_desc {
    echo "$1 $(git_hooks__extract_doc -a "git_hooks_${1//-/_}" | sed 's/^\s*//g')"
}


function git_hooks__extract_help {
    local cmd
    while read -r cmd; do
        printf "\\n    %s\\n" "$(git_hooks__extract_desc "$cmd")"
        git_hooks__extract_doc -h "git_hooks_${cmd//-/_}" | sed 's/^/    /g'
    done < <(grep "\$(git_hooks__extract_desc [-a-z]\\+)\$" "${bash_source}" | sed 's/.* \(.*\))/\1/g')
}


function git_hooks__extract_doc {
    local doc_type

    eval set -- "$($getopt -o ah -- "$@")"
    while [[ "$1" != -- ]]; do
        case "$1" in
            -a) doc_type=ARGS; shift;;
            -h) doc_type=HELP; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    type "$1" | awk "NR==1,/<<-${doc_type}/{next}/^${doc_type}/,NR==0{next}{print}"
}


function git_hooks_help {
    : <<-ARGS
	    [-m|--markdown]
	ARGS
    : <<-HELP
	    Displays this help message.

	    If --markdown is specified, the help message will be generated with
	    additional markdown syntax for headings and code blocks.
	HELP

    eval set -- "$($getopt -o m --long "markdown" -- "$@")"
    export USE_MARKDOWN=false;
    while [[ $1 != -- ]]; do
        case $1 in
            -m|--markdown)
                export USE_MARKDOWN=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift
    if [[ -n ${1:-} ]]; then
        printf "git hooks %s\\n" "$(git_hooks__extract_desc "$1")"
        echo
        git_hooks__extract_doc -h "git_hooks_${1//-/_}"
    else
        if [[ -t 1 ]]; then
            eval "echo \"$GITHOOKS_HELP\"" | less
        else
            eval "echo \"$GITHOOKS_HELP\""
        fi
    fi
}




function git_hooks_install {
    : <<-ARGS
	    [--no-preserve]
	ARGS
    : <<-HELP
	    Installs the multiplexer hooks into the .git/hooks directory.
	    These scripts are the core of the git-hooks functionality.
	    They are responsible for running any configured custom scripts
	    according to your specifications (sequential vs parallel,
	    disabled, etc.). This operation alse creates the .githooks
	    directory and moves any existing hooks into it. Any scripts
	    moved in this process will receive the "-moved" suffix.

	    If --no-preserve is specified, no existing hook scripts in
	    .git/hooks will be moved to the .githooks directory with the
	    "-moved" suffix.
	HELP

    local item preserve=true

    eval set -- "$($getopt -o "" --long "no-preserve" -- "$@")"
    while [[ ${1:-} != -- ]]; do
        case ${1:-} in
            --no-preserve) preserve=false; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    # Create the .git/hooks and .githooks directories
    mkdir -p "$repo_git_hooks_dir" "$githooks_dir"

    # Move existing hooks to .githooks dir
    # shellcheck disable=SC2015
    "$preserve" && printf "${c_action}%s ${c_value}%s${c_reset}\\n" "Moving existing hooks to" "$githooks_dir"
    shopt -s nullglob
    for item in "${repo_git_hooks_dir}/"*; do
        if ! [[ -h "$item" && "$(readlink "$item")" =~ git-hooks-multiplexer ]]; then
            if "$preserve"; then
                mv -v "$item" "${githooks_dir}/$(basename "$item")-moved" | sed "s/^/    /"
            else
                rm -f "$item"
            fi
        fi
    done
    shopt -u nullglob

    printf "${c_action}%s${c_reset}\\n" "Installing multiplexers"
    for hook in "${git_hook_names[@]}"; do
        item="${repo_git_hooks_dir}/${hook}"
        if ! [[ -h "$item" && "$(readlink "$item")" == "${bash_source_dir}/git-hooks-multiplexer" ]]; then
            ln -isv "${bash_source_dir}/git-hooks-multiplexer" "${repo_git_hooks_dir}/${hook}"
        fi
    done

    printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_value}%s ${c_action}%s${c_reset}\\n" \
        "Creating" ".githooks/config" "file and" ".githooks/.collections" "directory"
    mkdir -vp "${githooks_dir}/.collections"
    touch "${githooks_dir}/config"
    git add "${githooks_dir}/config"

    if [[ ! -f .gitignore ]] || ! grep -q "\\.githooks/\\.collections" ".gitignore"; then
        printf "${c_action}%s ${c_value}%s${c_reset}\\n" "Updating" ".gitignore"
        echo "$(basename "$githooks_dir")/.collections" >>.gitignore
        git add .gitignore
    fi
}




function git_hooks_add_collection {
    : <<-ARGS
	    [-g|--global] <collection name> <clone url> [<subpath to hooks>]
	ARGS
    : <<-HELP
	    Configures this repository to be able to reference git hooks hosted
	    in a remote locatior (currently only supports git repositories).

	    [-g|--global]:      The collection will be considered available to all repos.
	    <collection name>:  The internal name for the collection. Must be unique
	                        within this repository or if global, within all global
	                        collections.

	    <clone url>:        The collection's remote url.

	    <subpath to hooks>: The collection-relative path to the hook directories.
	HELP
    local hooks_dir="$githooks_dir"

    eval set -- "$($getopt -o g --long "global" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -g|--global) hooks_dir="$global_githooks_dir"; shift;;
        esac
    done
    shift

    local git_hooks_config="${hooks_dir}/config"
    local collections_path="${hooks_dir}/.collections"
    local c_name="$1" c_type="git" c_location="$2" c_subpath="${3:-}"

    mkdir -p "$hooks_dir"

    git config -f "$git_hooks_config" --unset-all collection.names "^${c_name}\$" &>/dev/null ||:
    git config -f "$git_hooks_config" --remove-section "collection.$c_name" &>/dev/null ||:
    rm -rf "${collections_path:?}/${c_name}"

    git config -f "$git_hooks_config" --add collection.names "$c_name"
    git config -f "$git_hooks_config" "collection.${c_name}.type" "$c_type"
    git config -f "$git_hooks_config" "collection.${c_name}.location" "$c_location"
    if [[ -n "$c_subpath" ]]; then
        git config -f "$git_hooks_config" "collection.${c_name}.subpath" "$c_subpath"
    fi
}





function git_hooks_list_collections {
    : <<-ARGS
	    [-g|--global]
	ARGS
    : <<-HELP
	    List the collections configured for the indicated scope.

	    [-g|--global]:      List collections configured at the global scope. If not
	                        specified, this will list collections configured for
	                        the current repository.
	HELP
    local hooks_dir="$githooks_dir"

    eval set -- "$($getopt -o g --long "global" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -g|--global) hooks_dir="$global_githooks_dir"; shift;;
        esac
    done
    shift

    local git_hooks_config="${hooks_dir}/config"
    local collections_path="${hooks_dir}/.collections"
    local c_name c_location c_path

    if [[ -d "$hooks_dir" ]]; then
        for c_name in $(git config -f "$git_hooks_config" --get-all collection.names); do
            c_location="$(git config -f "$git_hooks_config" --get "collection.${c_name}.location")"
            c_path="${collections_path}/${c_name}"
            cat <<-EOF
			${c_name}
			------------------
			Path:   ${c_path}
			Source: ${c_location}

			EOF
        done
    fi
}





function git_hooks_sync_collection {
    : <<-ARGS
	    [-g|--global] <collection name>
	ARGS
    : <<-HELP
	    Pull the latest updates for the indicated collection. This will happen
	    automatically periodically, but this command is for situations where
	    you don't want to wait for that automatic update to occur.

	    [-g|--global]:      The collection will be considered available to all repos.
	    <collection name>:  The internal name for the collection to be updated.
	HELP
    git_hooks__sync_collection --force "$@"
}





function git_hooks_uninstall {
    : <<-HELP
	    Removes the multiplexer hooks from the .git/hooks directory.
	HELP

    printf "${c_action}%s${c_reset}\\n" "Removing multiplexers"
    for hook in "${repo_git_hooks_dir}/"*; do
        if [[ -h "$hook" && "$(readlink "$hook")" =~ git-hooks-multiplexer ]]; then
            rm -v "$hook"
        fi
    done
}





# shellcheck disable=SC2120
function git_hooks_install_command {
    : <<-ARGS
	ARGS
    : <<-HELP
	    Creates a symlink to git-hooks in /usr/local/bin
	HELP

    if ! ln -isv "${bash_source}" "/usr/local/bin"; then
        printf >&2  "${c_action}%s ${c_value}%s${c_reset}" "Could not link to" "/usr/local/bin/git-hooks"
        return 1
    fi
}




# shellcheck disable=SC2120
function git_hooks_uninstall_command {
    : <<-ARGS
	ARGS
    : <<-HELP
	    Removes the symlink to git-hooks in /usr/local/bin, if present.
	HELP

    rm -f /usr/local/bin/git-hooks
}




function git_hooks_install_template {
    : <<-HELP
	    Installs the multiplexer scripts into ~/.gittemplate/hooks (or
	    into the location defined by the init.templateDir config value).
	    This will cause any subsequently cloned or created repositories to
	    automatically populate their .git/hooks directories with the
	    multiplexer script.

	    To update previously cloned repositories, just run 'git init' again.
	HELP

    local templatedir

    if ! templatedir="$(git config --global init.templateDir)"; then
        templatedir=~/.gittemplate
        printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_reset}\\n" "Setting" "init.templateDir = $templatedir" "in your global git config"
        git config --global --path init.templateDir "$templatedir"
    fi

    printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_reset}\\n" "Adding multiplexer hooks to" "${templatedir}/hooks" "directory"
    mkdir -p "${templatedir}/hooks"
    pushd "${templatedir}/hooks" >/dev/null
    for hook in "${git_hook_names[@]}"; do
        if ! [[ -h "$hook" && "$(readlink "$hook")" == "${bash_source_dir}/git-hooks-multiplexer" ]]; then
            ln -isv "${bash_source_dir}/git-hooks-multiplexer" "$hook"
        fi
    done
    popd >/dev/null

    cat <<-EOF

	    These multiplexer hooks will now be installed on any new repos created or cloned on this system.
	    To enable hooks for already existing repos, run 'git init' in those repos again.
	EOF

    mkdir -p "${templatedir}/info"
    echo ".githooks/.collections" >"${templatedir}/info/exclude"
}




function git_hooks_uninstall_template {
    : <<-HELP
	    Undoes the effects of 'install-template'.
	HELP
    local templatedir
    if templatedir="$(git config --global init.templateDir)"; then
        if [[ -d "${templatedir}/hooks" ]]; then
            printf "${c_action}%s ${c_value}%s ${c_action}%s${c_reset}\\n" "Removing multiplexer hooks from" "${templatedir}/hooks" "directory"
            pushd "${templatedir}/hooks" >/dev/null

            for hook in "${git_hook_names[@]}"; do
                [[ -h "$hook" ]] && rm -i "$hook"
            done

            popd >/dev/null
        fi
    fi
}




function git_hooks_check_support {
    : <<-HELP
	    Checks for differences in the list of hooks supported by
	    git-hooks and the list of hooks supported by git. If differences
	    are present, consider upgrading git-hooks or git.
	HELP
    local -a documented_hook_names
    # shellcheck disable=SC2207
    documented_hook_names=( $(git_hooks__extract_hook_names_from_man_page) )

    local known=("$(
        comm --nocheck-order -23 \
            <(echo "${git_hook_names[@]}" | xargs -n1 | sort) \
            <(echo "${documented_hook_names[@]}" | xargs -n1 | sort)
    )")
    local found=("$(
        comm --nocheck-order -13 \
            <(echo "${git_hook_names[@]}" | xargs -n1 | sort) \
            <(echo "${documented_hook_names[@]}" | xargs -n1 | sort)
    )")

    if [[ -n "${known[*]}" ]]; then
        printf "${c_action}%s${c_reset}\\n" "These hooks are not supported by your current version of git:"
        echo "${known[@]}" | xargs -n1 | sed 's/^/    /'
        echo
    fi

    if [[ -n "${found[*]}" ]]; then
        printf "${c_action}%s${c_reset}\\n" "These hooks are not yet supported by git-hooks:"
        echo "${found[@]}" | xargs -n1 | sed 's/^/    /'
        echo
    fi

    if [[ -z "${known[*]}" && -z "${found[*]}" ]]; then
        printf "${c_action}%s${c_reset}\\n" "All hooks are currently supported"
    fi
}




# shellcheck disable=SC2120
function git_hooks_list {
    : <<-ARGS
	    [<git hook>...]
	ARGS
    : <<-HELP
	    List all hooks for the current repository and their runnable state.
	HELP

    local total count=0 disabled=false unicode hook_name previous_hook_name hooks_list max_len=0 padding pad

    unicode="$(git config --bool git-hooks.unicode)" || unicode=true

    hooks_list="$(git_hooks__get_hooks "$@")"
    while read -r _ hook_name _ _; do
        max_len=$(( ${#hook_name}>max_len ? ${#hook_name} : max_len ))
    done <<<"$hooks_list"

    while read -r total hook_name hook hook_path; do
        [[ -n $total ]] || break

        echo -en "${c_reset}"
        if [[ "${previous_hook_name:-}" != "${hook_name}" ]]; then
            previous_hook_name="$hook_name"
            count=0

            git config --get-regexp "hooks\\.$hook_name\\.enabled" false &>/dev/null && disabled=true || disabled=false

            [[ -n "${previous_hook_name:-}" ]] && echo
            "$disabled" && echo -en "${c_error}"
            "$unicode" && padding="────────────────────" || padding="--------------------"
            pad=${padding:0:$(( max_len - ${#hook_name} + 1 ))}
            "$unicode" && echo -en "${hook_name}${pad}┐${c_reset}" || echo -en "${hook_name}${pad}|${c_reset}"
            "$disabled" && echo " (disabled)" || echo
        fi

        "$disabled" && connector="${c_error}" || connector=""
        if ((++count < total)); then
            "$unicode" && connector+="├─" || connector+="|-"
        else
            "$unicode" && connector+="└─" || connector+="|-"
        fi

        # shellcheck disable=2091
        if git config --get-regexp "hooks\\.${hook_name}-${hook}\\.enabled" false &>/dev/null; then
            printf " %${max_len}s${connector}${c_error}%s${c_reset} (disabled)\\n" "" "${hook}"
        elif "$disabled";then
            printf " %${max_len}s${connector}${c_error}%s${c_reset} (disabled by $hook_name)\\n" "" "${hook}"
        elif [[ -f "$hook_path" ]]; then
            if [[ -x "$hook_path" ]]; then
                printf " %${max_len}s${connector}%s${c_reset}\\n" "" "${hook}"
            else
                printf " %${max_len}s${connector}${c_error}%s${c_reset} (not executable)\\n" "" "${hook}"
            fi
        else
            printf " %${max_len}s${connector}${c_missing}%s${c_reset} (not found)\\n" "" "${hook}"
        fi
    done <<<"$hooks_list"
}

function git_hooks__get_hooks {
    local -a hook_names=( "${@:-${git_hook_names[@]}}" )
    local hook_dirs=""
    local hook_name total path name
    local global_enabled

    global_enabled=$(git config --bool git-hooks.global-enabled) || global_enabled=true

    [[ -d "$githooks_dir" ]] && hook_dirs="$hook_dirs $githooks_dir"
    "$global_enabled" && [[ -d "$global_githooks_dir" ]] && hook_dirs="$hook_dirs $global_githooks_dir"
    [[ -n "$hook_dirs" ]] || return

    for hook_name in "${hook_names[@]}"; do
        if ! git_hooks__is_git_hook "$hook_name"; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Not a valid git hook name:" "$hook_name"
            continue
        fi

        # shellcheck disable=2086
        total=$(find $hook_dirs -type f -path "*/${hook_name}*" -not -path "*/.collections/*" -not -name "*~" | wc -l)

        # shellcheck disable=2086
        while read -r path; do
            name="${path##*${hook_name}}"
            name="${name:1:${#name}}"
            echo "$total $hook_name $name $path"
        done < <(find $hook_dirs -type f -path "*/${hook_name}*" -not -path "*/.collections/*" -not -name "*~" | sort)
    done
}





function git_hooks_enable {
    : <<-ARGS
	    [-q|--quiet] <git hook>... <custom script name>...
	ARGS
    : <<-HELP
	    Enables a script (or scripts) to be run during git hook
	    invocation. Scripts are enabled by default.

	    If --quiet is specified, the updated enabled state of all hook
	    scripts will not be displayed.
	HELP

    local name quiet=false

    eval set -- "$($getopt -o q --long "quiet" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -q|--quiet) quiet=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    for name in "$@"; do
        git config --unset "hooks.$name.enabled" ||:
    done

    if ! "$quiet"; then
        # shellcheck disable=SC2119
        git_hooks_list
    fi
}




function git_hooks_disable {
    : <<-ARGS
	    [-q|--quiet] <git hook>... <custom script name>...
	ARGS
    : <<-HELP
	    Prevents a script from being run during git hook invocation.

	    If --quiet is specified, the updated enabled state of all hook
	    scripts will not be displayed.
	HELP

    local name quiet=false

    eval set -- "$($getopt -o q --long "quiet" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -q|--quiet) quiet=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    for name in "$@"; do
        git config --bool "hooks.$name.enabled" false
    done

    if ! "$quiet"; then
        # shellcheck disable=SC2119
        git_hooks_list
    fi
}




function git_hooks_run {
    : <<-ARGS
	    [-f|--force] <git hook>|<custom script name>
	ARGS
    : <<-HELP
	    Runs a git hook or an individual custom script. stdin and any
	    extra arguments will be forwarded to the designated target.

	    This command respects the enabled/disabled state of the hooks and
	    scripts. You can force the hook or script to run by specifying the
	    --force flag.
	HELP
    local hook name path

    eval set -- "$($getopt -o f --long "force" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -f|--force) export GITHOOKS_RUN=true; shift;;
            *) printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Unrecognized option:" "$1"; return 1;;
        esac
    done
    shift

    if [[ -z ${1:-} ]]; then
        printf >&2 "${c_error}%s${c_reset}\\n" "Must provide a git hook or custom script name:"
        # shellcheck disable=SC2119
        git_hooks_list
        return 1
    elif git_hooks__is_git_hook "$1"; then
        hook="$1"
    elif hook=$(git_hooks__git_hook_prefix "$1"); then
        name="$1"
    else
        printf >&2 "${c_error}%s${c_reset}\\n" "Not a valid git hook or custom script name"
        return 1
    fi
    shift ||:

    # Verify the presence of expected arguments
    case "$hook" in
        applypatch-msg) [[ $# == 1 ]] || { echo >&2 "Missing 1 parameter"; return 1; };;
        commit-msg) [[ $# == 1 ]] || { echo >&2 "Missing 1 parameter"; return 1; };;
        prepare-commit-msg) [[ $# == 1 ]] || { echo >&2 "Missing 1 parameters"; return 1; };;
        update) [[ $# == 3 ]] || { echo >&2 "Missing 3 parameters"; return 1; };;
        pre-receive|post-receive) [[ -t 0 ]] && { echo >&2 "Expected contents on stdin"; return 1; };;
    esac

    # Locate the hook or script path
    if [[ -z "${name:-}" ]];then
        # Run the multiplexer script
        path="${repo_git_hooks_dir}/${hook}"
    else
        if [[ -f "${githooks_dir}/${name}" ]]; then
            path="${githooks_dir}/${name}"
        elif [[ -f "${githooks_dir}/${hook}/${name#${hook}-}" ]]; then
            path="${githooks_dir}/${hook}/${name#${hook}-}"
        elif [[ -f "${global_githooks_dir}/${name}" ]]; then
            path="${global_githooks_dir}/${name}"
        elif [[ -f "${global_githooks_dir}/${hook}/${name#${hook}-}" ]]; then
            path="${global_githooks_dir}/${hook}/${name#${hook}-}"
        else
            printf >&2 "${c_error}%s${c_reset}\\n" "Could not find hook or custom script"
            return 1
        fi

        if [[ ! -f "$path" ]]; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook does not exist:" "$path"
            return 1
        elif [[ ! -x "$path" ]]; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook is not executable:" "$path"
            return 1
        fi
    fi

    pushd "$top_dir" >/dev/null
    "$path" "$@"
    popd >/dev/null
}




function git_hooks_parallel {
    : <<-ARGS
	    <git hook> [<num>]
	ARGS
    : <<-HELP
	    Modify the hooks.<git hook>.parallel config setting. <num> should
	    be the desired number of jobs to spawn when running the hook
	    scripts. If the second argument is not provided, it will display
	    the current setting. If <num> is 'max', it will be interpreted as
	    the number of CPUs as seen by cpuid. If <num> is "-", the current
	    setting will be cleared and the hook will not be run in parallel
	    mode.

	    When running in parallel, each script's output is buffered until
	    it finishes. When complete, the output will be written to stdout.
	HELP

    local hook_name="${1:-}" num="${2:-}"
    shift || { printf >&2 "${c_error}%s${c_reset}\\n" "Missing git hook name"; return 1; }

    if ! git_hooks__is_git_hook "$hook_name"; then
        printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Not a valid git hook name:" "$hook_name"
        return 1
    fi

    case $hook in
        -) git config --unset "hooks.${hook_name}.parallel" ||:;;
        *) git config "hooks.${hook_name}.parallel" "$num" ||:;;
    esac
}




function git_hooks_show_input {
    : <<-ARGS
	    <git hook> [true|false]
	ARGS
    : <<-HELP
	    Modify the hooks.<git hook>.showinput config setting. If no value
	    is provided, it will display the current setting. If this setting
	    is true, the received arguments and stdin will be displayed during
	    git hook invocation.
	HELP

    local hook_name="${1:-}" show="${2:-}"
    shift || { printf >&2 "${c_error}%s${c_reset}\\n" "Missing git hook name"; return 1; }

    if ! git_hooks__is_git_hook "$hook_name"; then
        printf >&2 "${c_error}%s${c_reset}\\n" "First argument must be a valid git hook name"
        return 1
    fi

    case "$show" in
        true|false|"") ;;
        *) printf >&2 "${c_error}%s${c_reset}\\n" "Second argument must be true, false or omitted"; return 1;;
    esac

    if [[ -n "$show" ]] && ! "$show"; then
        git config --unset "hooks.${hook_name}.showinput" ||:
    else
        git config --bool "hooks.${hook_name}.showinput" "$show" || echo false
    fi
}




function git_hooks_config {
    : <<-HELP
    Simply lists all hooks-related git config settings.
HELP

    local -a files=( system global )

    if git_hooks__require_git_dir; then
        files=( "${files[@]}" local )
    fi

    for location in "${files[@]}"; do
        printf "${c_action}%s${c_reset}\\n" "[$location]"
        git config "--$location" --get-regexp hooks ||:
        echo
    done
}




function git_hooks_include {
    : <<-ARGS
	    [-g|--global] <collection name> <git hook> <hook executable> [<new name>]
	ARGS
    : <<-HELP
	    Link an existing script from a collection into this repository.
	    If <new name> is provided, that name will be used instead of <hook script>
	    for the reference file installed into the repository. This is useful when one
	    wishes to specify a strict order to in which to run multiple scripts for
	    <git hook>. Just provide a numeric prefix on the <new name> to indicate
	    the script's place in the running order.

	    Specify '--global' if you want to reference a hook in a global collection.
	    Using this, it's possible to take advantage of project-agnostic hooks without
	    even placing them (or references to them) under your project's source control.
	    Bear in mind that some hooks will place files under the project's source
	    control as a side-effect of their behavior. This is to be expected.
	HELP
    local hooks_dir="$githooks_dir" global=''

    eval set -- "$($getopt -o g --long "global" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -g|--global) hooks_dir="$global_githooks_dir"; global='-g'; shift;;
        esac
    done
    shift

    local git_hooks_config="${hooks_dir}/config"
    local collections_path="${hooks_dir}/.collections"
    local c_name="$1" hook_name="$2" hook="$3" as="${4:-}" c_location c_subpath="" c_subpath_tmp src_path path

    # Ensure we know about the collection
    git config -f "$git_hooks_config" --get collection.names "$c_name" &>/dev/null
    c_location=$(git config -f "$git_hooks_config" --get "collection.${c_name}.location")

    git_hooks__sync_collection "$global" "$c_name" ||:
    git_hooks__ensure_collection "$global" "$c_name"

    # Check the collection repo first, then allow overrides from local repo
    if c_subpath_tmp=$(git config -f "${collections_path}/${c_name}/.git-hooks-collection" --get "collection.subpath") 2>/dev/null; then
        c_subpath="$c_subpath_tmp"
    fi
    if c_subpath_tmp=$(git config -f "$git_hooks_config" --get "collection.${c_name}.subpath") 2>/dev/null; then
        c_subpath="$c_subpath_tmp"
    fi

    src_path="${collections_path}/${c_name}/${c_subpath:+${c_subpath}/}${hook_name}/${hook}"
    if [[ -f "$src_path" ]]; then
        if [[ ! -x "$src_path" ]]; then
            printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook not executable:" "$src_path"
            return 1
        fi

        path="${hooks_dir}/${hook_name}/${as:-${hook}}"
        mkdir -p "$(dirname "$path")"
        printf '#!/usr/bin/env git-hooks\n\n' > "$path"
        git config -f "$path" git-hooks.collection "$c_name"
        git config -f "$path" git-hooks.hook "${hook_name}/${hook}"
        [[ -n "$global" ]] && git config -f "$path" --bool git-hooks.global true
        chmod +x "$path"
        printf "${c_action}%s ${c_value}%s ${c_action}%s ${c_value}%s${c_reset}\\n" \
            "Linked" "${path#*\.githooks/}" "to" "${src_path#${collections_path}/}"
    else
        printf >&2 "${c_error}%s ${c_value}%s${c_reset}\\n" "Hook not found:" "$src_path"
    fi
}



function git_hooks_update () {
    : <<-ARGS
	ARGS
    : <<-HELP
	    Force an update of the git-hooks tool. This will pull down the latest changes
	    and check out the latest release branch.
	HELP

    git_hooks__update_if_needed --force "${bash_source_dir}"
}


function git_hooks__update_if_needed {
    local repo_to_update force=false latest_version response

    eval set -- "$($getopt -o f --long "force" -- "$@")"
    while [[ $1 != -- ]]; do
        case $1 in
            -f|--force) force=true; shift;;
        esac
    done
    shift

    repo_to_update="$1"

    (
        pushd "$repo_to_update" >/dev/null
        if "$force" || git_hooks__update_check_needed; then
            git_hooks__mark_attempted
            git fetch >/dev/null
            latest_version="$(git tag -l --sort=-v:refname | head -n 1)"
            if [[ -z "$latest_version" ]]; then
                git pull >/dev/null
            elif [[ "$(git describe --tag)" == "$latest_version" ]]; then
                :
            elif git merge-base --is-ancestor HEAD "$latest_version"; then
                if "$force"; then
                    git checkout "$latest_version"
                    return
                fi

                printf >&2 "${c_prompt}%s${c_value}%s${c_prompt}%s${c_value}%s${c_prompt}%s ${c_reset}" "Updates available for $(basename "${repo_to_update}"): " "$(git describe --tag)" " -> " "$latest_version" ". Update now? ([y]es/[n]o):"
                read -r response
                case "$response" in
                    yes|y) git checkout "$latest_version" ;;
                    *) ;;
                esac
            fi
            git_hooks__mark_updated
        fi
        popd >/dev/null
    )
}

function git_hooks__update_check_needed {
    local last_attempted last_updated

    last_attempted="$(git config --local git-hooks.last-attempted 2>/dev/null)" || last_attempted=0
    last_updated="$(git config --local git-hooks.last-updated 2>/dev/null)" || last_updated=0

    (( "$(date -v "-7d" "+%s" 2>/dev/null || date -d "last week" "+%s")" > last_updated ))
    (( "$(date -v "-1d" "+%s" 2>/dev/null || date -d "yesterday" "+%s")" > last_attempted ))
}

function git_hooks__mark_attempted {
    git config --local git-hooks.last-attempted "$(date "+%s")"
}

function git_hooks__mark_updated {
    git config --local git-hooks.last-updated "$(date "+%s")"
}


# Globals
#############################################

# Populated in _verify_dirs
global_githooks_dir="$HOME/.githooks"
git_dir="$(git rev-parse --git-dir 2>/dev/null)" || git_dir=""
repo_dir="$(git rev-parse --show-toplevel 2>/dev/null)" || repo_dir=""
repo_is_bare="$(git rev-parse --is-bare-repository 2>/dev/null)" || repo_is_bare=false
if "$repo_is_bare"; then
    top_dir="$git_dir"
    repo_git_hooks_dir="$(git config core.hooksPath || echo "${git_dir}/hooks")"
    githooks_dir="${top_dir}/.githooks"
elif [[ -n "$repo_dir" ]]; then
    top_dir="$repo_dir"
    repo_git_hooks_dir="$(git config core.hooksPath || echo "${git_dir}/hooks")"
    githooks_dir=${top_dir}/.githooks
else
    top_dir=
    repo_git_hooks_dir=
    githooks_dir=
fi

# Main functionality
#############################################
function git_hooks__main {
    # Ensure we have prerequisite tools
    git_hooks__ensure_modern_bash
    git_hooks__ensure_gnu_getopt

    # What command were we given?
    git_hooks_command="${1:-list}"; shift ||:

    # Determine the correct command to run and pass it the rest of the un-parsed options
    case "$git_hooks_command" in
        # Require a git repository for these commands
        install|uninstall|list|disable|enable|run|parallel|show-input)
            git_hooks__require_git_dir
            ;;

        # No special requirements
        update|add-collection|list-collections|sync-collection|check-support|install-command|uninstall-command|install-template|uninstall-template|config|help|include)
            ;;

        *)  printf >&2 "${c_error}%s ${c_value}%s ${c_error}%s${c_reset}\\n" "git-hooks:" "$git_hooks_command" "is not a git-hooks command." >&2
            exit 1
            ;;
    esac

    "git_hooks_${git_hooks_command//-/_}" "$@"
}

# "#!/usr/bin/env git-hooks" functionality
#############################################
function git_hooks__run_referenced_hook {
    # This function executes a "script" created by the "git hooks include" command
    local c_global c_name c_subpath
    local hooks_dir
    local git_hooks_config
    local collections_path
    local hook_path="$1"
    shift

    c_global="$(git config -f "$hook_path" --bool --get git-hooks.global)" ||:
    if [[ -n "$c_global" && "$c_global" ]]; then
        hooks_dir=${global_githooks_dir}
        c_global="-g"
    else
        hooks_dir=${githooks_dir}
        c_global=""
    fi

    c_name="$(git config -f "$hook_path" --get git-hooks.collection)"
    c_subpath="$(git config -f "${hooks_dir}/config" --get "collection.${c_name}.subpath")" ||:
    git_hooks_config="${hooks_dir}/config"
    collections_path="${hooks_dir}/.collections"

    # Check the collection repo first, then allow overrides from local repo
    if c_subpath_tmp=$(git config -f "${collections_path}/${c_name}/.git-hooks-collection" --get "collection.subpath") 2>/dev/null; then
        c_subpath="$c_subpath_tmp"
    fi
    if c_subpath_tmp=$(git config -f "$git_hooks_config" --get "collection.${c_name}.subpath") 2>/dev/null; then
        c_subpath="$c_subpath_tmp"
    fi

    # Retrieve/update the collection referenced in this config
    git_hooks__sync_collection "$c_global" "$c_name" ||:
    git_hooks__ensure_collection "$c_global" "$c_name"

    "${hooks_dir}/.collections/${c_name}/${c_subpath:+${c_subpath}/}$(git config -f "$hook_path" --get git-hooks.hook)" "$@"
}

# Determine if this file is being sourced or invoked
unset BASH_SOURCE 2>/dev/null ||:
# shellcheck disable=2015
if [[ ".$0" == ".${BASH_SOURCE[0]}" ]]; then
    # If we're here, this file is being run, not sourced

    # Determine if it was run as the interpreter for #!/usr/bin/env git-hook scripts
    # or just run as a direct call.
    if [[ -n "${1:-}" && "${invocation}" == "$1" ]]; then
        # This is the "interpreter" mode. This happens when one of the "include"
        # configurations is run.

        git_hooks__run_referenced_hook "$@"
    else
        git_hooks__main "$@" ||:
    fi
fi
